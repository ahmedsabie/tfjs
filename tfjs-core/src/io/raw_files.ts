/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */

/**
 * IOHandlers related to the node file system
 */

import '../flags';

import {basename, concatenateArrayBuffers} from './io_utils';
import {IOHandler, ModelArtifacts, ModelJSON, WeightsManifestConfig, WeightsManifestEntry} from './types';

class RawFiles implements IOHandler {
  constructor(
      private readonly modelData: string,
      private readonly pathToWeightsData: {[fileName: string]: ArrayBuffer}) {}

  async load(): Promise<ModelArtifacts> {
    return new Promise<ModelArtifacts>((resolve, reject) => {
      // tslint:disable-next-line:no-any
      const modelJSON = JSON.parse(this.modelData) as ModelJSON;
      const modelTopology = modelJSON.modelTopology;
      if (modelTopology == null) {
        reject(new Error(`modelTopology field is missing from model JSON`));
        return;
      }

      if (Object.keys(this.pathToWeightsData).length === 0) {
        resolve({modelTopology});
      }

      const weightsManifest = modelJSON.weightsManifest;
      if (weightsManifest == null) {
        reject(new Error(`weightManifest field is missing from model JSON`));
        return;
      }

      try {
        this.checkManifestAndWeightFiles(weightsManifest);
      } catch (err) {
        reject(err);
        return;
      }

      const weightSpecs: WeightsManifestEntry[] = [];
      const paths: string[] = [];
      const perFileBuffers: ArrayBuffer[] = [];
      weightsManifest.forEach(weightsGroup => {
        weightsGroup.paths.forEach(path => {
          paths.push(path);
          perFileBuffers.push(null);
        });
        weightSpecs.push(...weightsGroup.weights);
      });

      weightsManifest.forEach(weightsGroup => {
        weightsGroup.paths.forEach(path => {
          // tslint:disable-next-line:no-any
          const weightData = this.pathToWeightsData[path];
          const index = paths.indexOf(path);
          perFileBuffers[index] = weightData;
          if (perFileBuffers.indexOf(null) === -1) {
            const result: ModelArtifacts = {
              modelTopology,
              weightSpecs,
              weightData: concatenateArrayBuffers(perFileBuffers),
              format: modelJSON.format,
              generatedBy: modelJSON.generatedBy,
              convertedBy: modelJSON.convertedBy
            };
            if (modelJSON.signature != null) {
              result.signature = modelJSON.signature;
            }
            if (modelJSON.userDefinedMetadata != null) {
              result.userDefinedMetadata = modelJSON.userDefinedMetadata;
            }
            if (modelJSON.modelInitializer != null) {
              result.modelInitializer = modelJSON.modelInitializer;
            }
            resolve(result);
          }
        });
      });
    });
  }

  /**
   * Check the compatibility between weights manifest and weight files.
   */
  private checkManifestAndWeightFiles(manifest: WeightsManifestConfig) {
    const basenames: string[] = [];
    const fileNames = Object.keys(this.pathToWeightsData)
    for (const group of manifest) {
      group.paths.forEach(path => {
        const pathBasename = basename(path);
        if (basenames.indexOf(pathBasename) !== -1) {
          throw new Error(
              `Duplicate file basename found in weights manifest: ` +
              `'${pathBasename}'`);
        }
        basenames.push(pathBasename);
        if (fileNames.indexOf(pathBasename) === -1) {
          throw new Error(
              `Weight file with basename '${pathBasename}' is not provided.`);
        }
      });
    }

    if (basenames.length !== fileNames.length) {
      throw new Error(
          `Mismatch in the number of files in weights manifest ` +
          `(${basenames.length}) and the number of weight files provided ` +
          `(${fileNames.length}).`);
    }
  }
}

/**
 * Creates an IOHandler that loads model artifacts from local files in node.
 *
 * This function supports loading models generated by `tensorflowjs_converter`
 * that comes with the `tensorflowjs` Python PIP package.
 *
 * @param modelData A JSON file containing the model topology and weight
 *     manifest.
 * @param pathToWeightsData A mapping from the name of the weight file to the
 *     binary file content containing the binary weights.
 *     These files must have names that match the paths in the `weightsManifest`
 *     contained by the aforementioned JSON file, or errors will be thrown
 *     during loading. If no weights files are provided, only the model
 *     topology will be loaded from the JSON file above.
 * @returns An instance of `RawFiles` `IOHandler`.
 *
 * @doc {
 *   heading: 'Models',
 *   subheading: 'Loading',
 *   namespace: 'io',
 *   ignoreCI: true
 * }
 */
export function rawFiles(
    modelData: string,
    pathToWeightsData: {[fileName: string]: ArrayBuffer} = {}): IOHandler {
  return new RawFiles(modelData, pathToWeightsData);
}
